# RFC: Simplified Multi-Version Release Strategy

**Date:** 2025-10-25  
**Status:** ---  
**Author:** @derese-getachew

---

## 1. Summary

This document proposes a standardized strategy for managing releases across the monorepo. To balance simplicity with the need for long-term support (LTS), we will introduce two distinct operational modes for release management.

1.  **Single-Release Mode (Default):** For most projects. We only develop and release from the `main` branch. No long-term support for older versions is provided.
2.  **Multi-Release Mode (Opt-in):** For mature libraries requiring LTS. This mode enables patching older major versions while developing new ones.

This approach allows new projects to move quickly while providing stability for established ones.

---

## 2. The Proposal: Two Release Modes

A repository's release mode is determined by the `ENABLE_MULTI_RELEASE` flag at the time of its creation.

| Mode                 | `ENABLE_MULTI_RELEASE` | Description                                                                                             | Use Case                        |
| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------- |
| **Single-Release**   | `false` (default)      | All work happens on `main`. Only the latest version is supported.                                       | New or internal projects.       |
| **Multi-Release**    | `true`                 | `main` is for the next major version. Long-lived `release/*` branches are used for patching older majors. | Stable libraries with adopters. |

---

## 3. Branching & Release Workflow (Multi-Release Mode)

When `ENABLE_MULTI_RELEASE` is true, we adopt a specific branching model for LTS.

#### Key Branches

*   `main`: The primary branch for active development of the *next* major version. All new features and breaking changes land here.
*   `release/<package>_<major>`: Long-lived maintenance branches for *previous* major versions (e.g., `release/lib-one_1`). These branches only accept bug fixes and security patches.

#### Creating a Maintenance Branch

The creation of maintenance branches is now **fully automated** by the CI/CD pipeline. When a "Version Packages" pull request that includes a major version bump is merged, the release workflow automatically performs the following steps:

1.  **Branch Planning**: A `version.js` script runs before versioning. It analyzes the pending changesets, identifies any major version bumps, and creates a `.release-meta/maintenance-branches.json` file. This file acts as a "contract," defining which maintenance branches need to be created.
2.  **"Version Packages" PR**: The `changesets/action` creates a pull request containing the version bumps, changelogs, and the `maintenance-branches.json` plan file. This makes the release plan fully transparent and reviewable.
3.  **Branch Creation**: After the PR is merged, a `release.js` script reads the `maintenance-branches.json` file. For each entry, it creates the specified maintenance branch (e.g., `release/lib-one_v1`) from the commit *just before* the version bump merge (`HEAD~1`). This correctly freezes the old major version line.
4.  **Publishing**: Finally, the script publishes the new package versions to npm.

#### Patching an Old Version

Fixes intended for a maintenance version must be cherry-picked from `main` into the appropriate `release/*` branch. **We never merge `main` back into a release branch.**

```bash
# 1. Bring the fix from main into the maintenance branch
git checkout release/lib-one_1
git cherry-pick <commit-hash-from-main>

# 2. Release the patch from the maintenance branch
pnpm changeset version # Bumps to 1.x.y
pnpm changeset publish
```

---

## 4. CI/CD Strategy

Our CI/CD pipelines will adapt based on the selected release mode.

*   **Workflows:**
    *   **Single-Release:** CI runs only on the `main` branch.
    *   **Multi-Release:** CI runs on `main` and all active `release/*` branches.
*   **Code Coverage:**
    *   Coverage reports will be generated and compared on a *per-branch basis*.
    *   This ensures that a branch's coverage is only compared against its own history, preventing false negatives between different major versions.

---

## 5. Contributor Workflow

| Scenario                        | Action                                                                 |
| ------------------------------- | ---------------------------------------------------------------------- |
| **New Feature / Breaking Change** | Open a PR against `main`.                                              |
| **Bug Fix (latest version)**      | Open a PR against `main`.                                              |
| **Bug Fix (older version)**       | Open a PR against `main` first, then cherry-pick the fix to a new PR against the `release/*` branch. |
| **Security Patch**              | Same as a bug fix. Patch `main` first, then cherry-pick to maintenance branches as needed. |

---

## 6. Future Considerations

The following items are part of the long-term vision but are out of scope for the initial implementation.

*   **Automated Test Matrix:** A script will dynamically generate the CI test matrix based on the `engines.node` and `peerDependencies` in each package's `package.json`.
*   **Versioned Documentation:** The documentation site will support a version switcher, allowing users to view docs corresponding to each maintained major version.

---

## 7. Implementation Plan

This project will be implemented in phases, starting with repository configuration and progressing through CI/CD updates, script creation, and finally, documentation.

### Phase 1: Repository Configuration

- [x] **1.1: Define `ENABLE_MULTI_RELEASE` Flag**
    - **Action:** Use a GitHub repository variable named `ENABLE_MULTI_RELEASE` to control the release mode. This is easily configurable in the repository settings (`Settings > Secrets and variables > Actions`).
    - **Default:** Set the value to `false` for existing and new repositories.

### Phase 2: CI/CD Workflow Updates (`.github/workflows/ci-build-lint-test-wf.yml`)

- [x] **2.1: Update Workflow Triggers**
    - **Action:** Modify the `on:` block to include `release/*` branches.
    - **Change:**
      ```yaml
      on:
        # ... (keep existing triggers)
        push:
          branches: [main, 'release/*']
        pull_request:
          types: [opened, reopened, synchronize, labeled, unlabeled]
          branches: [main, 'release/*']
      ```

- [x] **2.2: Adapt Publish Job for Multi-Release**
    - **Action:** Update the `if` condition for the `publish` job to allow publishing from `main` and `release/*` branches.
    - **Change:**
      ```yaml
      publish:
        # ...
        if: >
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/release/'))
      ```

- [x] **2.3: Per-Branch Code Coverage**
    - **Action:** Modify the `build` job (or the `.github/actions/build-lint-test` action it calls) to create branch-specific coverage artifacts.
    - **Logic:** The name of the uploaded coverage artifact should include the branch name (e.g., `coverage-baseline-${{ github.ref_name }}`). The script that calculates the coverage diff must be updated to download the correct baseline for the current branch.

### Phase 3: Create an Intelligent Release Script

- [x] **3.1: Create New Release Script File**
    - **Action:** Create two new scripts: `.github/scripts/release/version.js` (for pre-versioning logic) and `.github/scripts/release/release.js` (for publishing logic).

- [x] **3.2: Implement Release Logic with Auto-Branching**
    - **Action:** The release logic is split between the two scripts to create a transparent, two-step process.
        - **`version.js` (Pre-Versioning):**
            1.  **Parse Changesets:** Reads all files in the `.changeset` directory to find packages being bumped to a new `major` version.
            2.  **Plan Branches:** For each major bump, it determines the current major version (e.g., if bumping to `v2.0.0`, the current is `v1`) and calculates the required maintenance branch name (e.g., `release/<package-name>_v1`).
            3.  **Create Plan File:** Writes the plan to `.release-meta/maintenance-branches.json`. This file is committed as part of the "Version Packages" PR.
            4.  **Run Version Command:** Finally, it executes `pnpm changeset version`.
        - **`release.js` (Publishing):**
            1.  **Read Plan File:** After the "Version Packages" PR is merged, this script reads the `.release-meta/maintenance-branches.json` file.
            2.  **Check for Branch:** For each entry in the plan, it checks if the corresponding maintenance branch already exists on the remote.
            3.  **Create Branch:** If the branch does not exist, the script automatically runs `git branch <branch-name> HEAD~1` and `git push origin <branch-name>` to create the branch from the commit before the version bump.
            4.  **Publish:** After creating all required branches, the script runs `pnpm changeset publish`.

- [x] **3.3: Update `package.json`**
    - **Action:** The release process is no longer triggered by a local `pnpm release` script. It is now fully managed by the `changesets/action` in the CI/CD workflow.
    - **Change:** The `version` and `publish` steps in `.github/workflows/ci-build-lint-test-wf.yml` are configured to call `version.js` and `release.js` respectively.

### Phase 4: Documentation

- [ ] **4.1: Create `CONTRIBUTING.md`**
    - **Action:** Create a `CONTRIBUTING.md` file in the root of the repository.
    - **Content:** Explain the branching strategy, how to submit PRs for features vs. bug fixes, and the process for cherry-picking fixes to maintenance branches.

- [ ] **4.2: Update `README.md`**
    - **Action:** Add a section to the main `README.md` that briefly describes the project's support policy (single-release vs. multi-release) and links to the new `CONTRIBUTING.md` for details.
