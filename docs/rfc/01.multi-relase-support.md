# RFC: Simplified Multi-Version Release Strategy

**Date:** 2025-10-25  
**Status:** ---  
**Author:** @derese-getachew

---

## 1. Summary

This document proposes a standardized strategy for managing releases across the monorepo. To balance simplicity with the need for long-term support (LTS), we will introduce two distinct operational modes for release management.

1.  **Single-Release Mode (Default):** For most projects. We only develop and release from the `main` branch. No long-term support for older versions is provided.
2.  **Multi-Release Mode (Opt-in):** For mature libraries requiring LTS. This mode enables patching older major versions while developing new ones.

This approach allows new projects to move quickly while providing stability for established ones.

---

## 2. The Proposal: Two Release Modes

A repository's release mode is determined by the `ENABLE_MULTI_RELEASE` flag at the time of its creation.

| Mode                 | `ENABLE_MULTI_RELEASE` | Description                                                                                             | Use Case                        |
| -------------------- | ---------------------- | ------------------------------------------------------------------------------------------------------- | ------------------------------- |
| **Single-Release**   | `false` (default)      | All work happens on `main`. Only the latest version is supported.                                       | New or internal projects.       |
| **Multi-Release**    | `true`                 | `main` is for the next major version. Long-lived `release/*` branches are used for patching older majors. | Stable libraries with adopters. |

---

## 3. Branching & Release Workflow (Multi-Release Mode)

When `ENABLE_MULTI_RELEASE` is true, we adopt a specific branching model for LTS.

#### Key Branches

*   `main`: The primary branch for active development of the *next* major version. All new features and breaking changes land here.
*   `release/<package>_<major>`: Long-lived maintenance branches for *previous* major versions (e.g., `release/lib-one_1`). These branches only accept bug fixes and security patches.

#### Creating a Maintenance Branch

Just before releasing a new major version (e.g., `v2.0.0`) from `main`, we must create a maintenance branch for the current major version (e.g., `v1.x`).

```bash
# 1. Create the maintenance branch from the current state of main
git checkout -b release/lib-one_1
git push origin release/lib-one_1

# 2. Return to main, bump to the new major, and release
git checkout main
# ... (use changesets to set the new major version) ...
pnpm changeset version
pnpm changeset publish
```

#### Patching an Old Version

Fixes intended for a maintenance version must be cherry-picked from `main` into the appropriate `release/*` branch. **We never merge `main` back into a release branch.**

```bash
# 1. Bring the fix from main into the maintenance branch
git checkout release/lib-one_1
git cherry-pick <commit-hash-from-main>

# 2. Release the patch from the maintenance branch
pnpm changeset version # Bumps to 1.x.y
pnpm changeset publish
```

---

## 4. CI/CD Strategy

Our CI/CD pipelines will adapt based on the selected release mode.

*   **Workflows:**
    *   **Single-Release:** CI runs only on the `main` branch.
    *   **Multi-Release:** CI runs on `main` and all active `release/*` branches.
*   **Code Coverage:**
    *   Coverage reports will be generated and compared on a *per-branch basis*.
    *   This ensures that a branch's coverage is only compared against its own history, preventing false negatives between different major versions.

---

## 5. Contributor Workflow

| Scenario                        | Action                                                                 |
| ------------------------------- | ---------------------------------------------------------------------- |
| **New Feature / Breaking Change** | Open a PR against `main`.                                              |
| **Bug Fix (latest version)**      | Open a PR against `main`.                                              |
| **Bug Fix (older version)**       | Open a PR against `main` first, then cherry-pick the fix to a new PR against the `release/*` branch. |
| **Security Patch**              | Same as a bug fix. Patch `main` first, then cherry-pick to maintenance branches as needed. |

---

## 6. Future Considerations

The following items are part of the long-term vision but are out of scope for the initial implementation.

*   **Automated Test Matrix:** A script will dynamically generate the CI test matrix based on the `engines.node` and `peerDependencies` in each package's `package.json`.
*   **Versioned Documentation:** The documentation site will support a version switcher, allowing users to view docs corresponding to each maintained major version.

---

## 7. Implementation Plan

This project will be implemented in phases, starting with repository configuration and progressing through CI/CD updates, script creation, and finally, documentation.

### Phase 1: Repository Configuration

- [x] **1.1: Define `ENABLE_MULTI_RELEASE` Flag**
    - **Action:** Use a GitHub repository variable named `ENABLE_MULTI_RELEASE` to control the release mode. This is easily configurable in the repository settings (`Settings > Secrets and variables > Actions`).
    - **Default:** Set the value to `false` for existing and new repositories.

### Phase 2: CI/CD Workflow Updates (`.github/workflows/ci-build-lint-test-wf.yml`)

- [x] **2.1: Update Workflow Triggers**
    - **Action:** Modify the `on:` block to include `release/*` branches.
    - **Change:**
      ```yaml
      on:
        # ... (keep existing triggers)
        push:
          branches: [main, 'release/*']
        pull_request:
          types: [opened, reopened, synchronize, labeled, unlabeled]
          branches: [main, 'release/*']
      ```

- [x] **2.2: Adapt Publish Job for Multi-Release**
    - **Action:** Update the `if` condition for the `publish` job to allow publishing from `main` and `release/*` branches.
    - **Change:**
      ```yaml
      publish:
        # ...
        if: >
          (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
          (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/release/'))
      ```

- [x] **2.3: Per-Branch Code Coverage**
    - **Action:** Modify the `build` job (or the `.github/actions/build-lint-test` action it calls) to create branch-specific coverage artifacts.
    - **Logic:** The name of the uploaded coverage artifact should include the branch name (e.g., `coverage-baseline-${{ github.ref_name }}`). The script that calculates the coverage diff must be updated to download the correct baseline for the current branch.

### Phase 3: Create an Intelligent Release Script

- [x] **3.1: Create New Release Script File**
    - **Action:** Create a new script at `scripts/release.js` to house the new release logic.

- [x] **3.2: Implement Release Logic with Auto-Branching**
    - **Action:** The script will read the `ENABLE_MULTI_RELEASE` variable.
        - If `false`, it will simply execute `changeset publish`.
        - If `true` and on the `main` branch, it will perform automated pre-flight checks:
            1.  **Parse Changesets:** Read all files in the `.changeset` directory to find packages being bumped to a new `major` version.
            2.  **For each major bump:** Determine the current major version (e.g., if bumping to `v2.0.0`, the current is `v1`).
            3.  **Check for Branch:** Check if the corresponding maintenance branch (e.g., `release/<package-name>_v1`) already exists on the remote.
            4.  **Create Branch:** If the branch does not exist, the script will automatically run `git branch release/<package-name>_v1 HEAD` and `git push origin release/<package-name>_v1` to create and push the new maintenance branch.
            5.  **On a `release/*` branch:** The script will still fail if it detects a `major` version changeset, as this is not allowed on maintenance branches.
    - **Action:** After checks and auto-branching are complete, the script will run `changeset publish`.

- [x] **3.3: Update `package.json`**
    - **Action:** Change the `release` script in the root `package.json` to use the new script.
    - **Change:**
      ```json
      "scripts": {
        "release": "node ./scripts/release.js"
      },
      ```

### Phase 4: Documentation

- [ ] **4.1: Create `CONTRIBUTING.md`**
    - **Action:** Create a `CONTRIBUTING.md` file in the root of the repository.
    - **Content:** Explain the branching strategy, how to submit PRs for features vs. bug fixes, and the process for cherry-picking fixes to maintenance branches.

- [ ] **4.2: Update `README.md`**
    - **Action:** Add a section to the main `README.md` that briefly describes the project's support policy (single-release vs. multi-release) and links to the new `CONTRIBUTING.md` for details.
