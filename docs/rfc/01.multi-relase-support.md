# RFC: Multi-Version Release & Maintenance Branch Strategy

**Date:** 2025-10-25  
**Status:** ---  
**Authors:** @derese-getachew  
**Tags:** release-management, ci, versioning, documentation, changesets  

---

## 1. Problem Statement
Our monorepo template is built to host multiple libraries and as libraries evolve, we need to continue fixing and publishing older major versions (e.g., lib@1.x) while developing newer ones (lib@2.x).

Currently, all automation, coverage, and docs assume a single “main” development line. This limits our ability to:

- Maintain multiple active versions with different peer dependencies
- Apply security and bug fixes to older majors
- Compare test coverage or generate docs per version line
- Release safely without interfering with future versions

We need a branching, CI, and release model that supports concurrent version lines.

By default, the system operates in **single-release mode** (multi-version support disabled). When the environment variable `ENABLE_MULTI_RELEASE=true` is set, all mechanisms described below activate to enable multi-version release and maintenance workflows.

## 2. Proposal
Adopt a multi-version release workflow using long-lived maintenance branches and branch-aware CI pipelines, **activated only when `ENABLE_MULTI_RELEASE=true`**.

### Overview
- **Single-release mode (default):** workflows trigger on `main` only, a single line of development and release.
- **Multi-release mode (enabled):** each maintained major version of a library has its own branch, coverage baseline, and documentation snapshot.
- Branching, CI, coverage, publishing, and documentation processes adapt to support multiple active versions in parallel.

### 2.1 Branching Model
| Branch Type       | Example                      | Purpose                                                      |
|-------------------|------------------------------|--------------------------------------------------------------|
| Active Development | `main`                       | Latest major line (new features, breaking changes allowed)   |
| Maintenance       | `release/<package>_V<major>` | Long-lived branch for older major line (bugfixes, security patches only) |

When creating a new major (only applicable if `ENABLE_MULTI_RELEASE=true`):

```bash
# Before bumping inbox to v2.0.0
git checkout -b release/lib_V2 main
git push origin release/lib_V2
```

- `main` continues toward v2 and beyond
- `release/<package>_V1` supports the v1.x series

Each branch maintains its own:

- `.changeset` directory
- CI configuration
- Documentation version
- Compatible Node runtime versions and peer dependencies

If multi-version support is disabled, only `main` is used.

### 2.2 CI & Coverage
**Goals**

- Make test and coverage baselines branch-scoped.
- Prevent cross-major coverage comparisons.

**Implementation**

- **Single-release mode:** workflows trigger only on `main`.
- **Multi-release mode (`ENABLE_MULTI_RELEASE=true`):** trigger workflows on `main` and `release/*`.
- Use branch-specific artifact names, e.g.:

  - `coverage-baseline-main`
  - `coverage-baseline-release_inbox_1`

- Coverage comparison always references the latest artifact for the same branch.
- Coverage messages update to:

  > “Coverage changed from X % → Y % compared to the previous successful run on this branch.”

**Runtime Matrix**

The CI configuration dynamically selects the runtime environment per branch to match the supported Node and NestJS versions for that branch. For example:

```yaml
jobs:
  test:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: [18, 20]
    steps:
      - name: Set Node version based on branch
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "NODE_VERSION=20" >> $GITHUB_ENV
          elif [[ "${{ github.ref }}" =~ refs/heads/release/lib_V1 ]]; then
            echo "NODE_VERSION=18" >> $GITHUB_ENV
          fi
      - name: Use Node.js ${{ env.NODE_VERSION }}
        uses: actions/setup-node@v3
        with:
          node-version: ${{ env.NODE_VERSION }}
      # ... rest of the steps
```

This ensures that tests run with the appropriate runtime for each branch, reflecting their supported versions. In single-release mode, this logic simplifies to always use the main branch's runtime.

### 2.3 Release & Publishing Workflow
**Requirements**

- Allow independent releases from maintenance branches.
- Keep semver lines isolated.
- Block major bumps in release branches.

**Workflow**

- **Single-release mode:** trigger on `main` only.
- **Multi-release mode:** trigger on both `main` and `release/*` branches:

```yaml
on:
  push:
    branches:
      - main
      - release/*
```

- Commands:

  ```bash
  pnpm changeset version
  # Commit version bumps to the same branch
  pnpm changeset publish
  ```

- Create a signed git tag per published package version, e.g., `@nestcourier/inbox@1.6.3`
- A guard script fails CI if branch is `release/*` and a pending changeset includes a major bump.
- Tags and changelogs remain branch-specific.

If multi-release mode is disabled, only the `main` branch is used for releases and the guard script is inactive.

### 2.4 Documentation Versioning
| Branch               | Output Path         | Status                                    |
|----------------------|---------------------|-------------------------------------------|
| `main`               | `/<package>/v2`     | Current (latest major, actively developed)|
| `release/<package>_1`| `/<package>/v1`     | Maintenance (frozen, updated only for fixes)|

**Implementation**

- Docs generator writes to `docs/generated/<package>/<majorLine>/…`.
- Add version switcher to docs site (e.g., v1 ↔ v2).
- `/v1` docs are frozen and updated only from `release/inbox_1`.

Versioned documentation generation and the version switcher activate only when `ENABLE_MULTI_RELEASE=true`. Otherwise, docs are generated only for the `main` branch.

### 2.5 Dependency & Tooling Policy
- Dependabot targets only `main`; security backports to maintenance branches are manual and done as needed.
- Security Fixes: Dependabot and GitHub advisories handle dependency CVEs automatically on `main`. Runtime-specific issues (e.g., Node or NestJS versions) require best-effort manual fixes applied to all affected branches still under maintenance.

**CODEOWNERS**

A single CODEOWNERS file covers all branches, with optional branch or path pattern-based ownership. For example:

```
# Ownership for all release branches
release/* @core-maintainers
```

This ensures consistent ownership and review policies across maintenance branches.

**Branch Protection**

- Require PR + passing CI
- Restrict merge access
- No branch merges

We avoid merging `main` into `release/*` branches to prevent unintended breaking changes. However, PRs and direct commits are allowed on release branches for bug fixes and security patches. Cherry-picking from `main` to release branches is encouraged for applying relevant fixes.

### 2.6 Contributor Workflow
| Scenario                      | Action                                                                                   |
|------------------------------|------------------------------------------------------------------------------------------|
| Bug affects both new & old lines | Fix on `main`, then cherry-pick to relevant `release/*` via PRs                        |
| Bug only in old line          | Fix directly on that branch via PR                                                      |
| New feature or breaking change| Only on `main`                                                                         |
| Security fix                 | Dependabot + GitHub advisories handle dependency CVEs on `main`. Runtime-specific fixes are applied manually to all affected branches still in maintenance window via PRs. |

Never merge entire branches; use cherry-pick:

```bash
git cherry-pick <commit-sha>
```

### 2.7 Maintenance & Support Policy
A shared `SUPPORTED_VERSIONS.md` will list all maintained lines:

| Package                | Line | Node          | NestJS | Status      | Maintained Until |
|------------------------|------|---------------|--------|-------------|------------------|
| @nestcourier/inbox     | 2.x  | ≥ 20          | ^11    | Active      | —                |
| @nestcourier/inbox     | 1.x  | ≥ 18 < 22     | ^10    | Maintenance | 2026-06-30       |

---

## 3. Implementation Plan
| Phase | Focus              | Deliverables                                                        |
|-------|--------------------|-------------------------------------------------------------------|
| 0     | Policy & Governance | `MAINTENANCE_BRANCHES.md`, `SUPPORTED_VERSIONS.md`, branch naming convention |
| 1     | CI Foundations     | Workflow triggers for `release/*`, CODEOWNERS, per-branch test matrix |
| 2     | Coverage           | Branch-aware artifact naming and comparison                        |
| 3     | Publishing         | Changesets flow per branch, tag strategy, major-bump guard        |
| 4     | Docs               | Versioned docs generation and switcher                            |
| 5     | Contributor Ops    | Dependabot and security backport policy                            |

---

## 4. Trade-offs
**Advantages**

- True long-term support (LTS) for older majors
- Isolated release pipelines and coverage
- Predictable semver and docs versioning
- Supports different NestJS/Node combinations per line

**Drawbacks**

- Slightly higher CI maintenance cost
- Duplicated configs across branches
- Requires discipline for cherry-picking
- Dependabot limited to `main` branch

---

## 5. Alternatives Considered
| Option                     | Reason Rejected                                      |
|----------------------------|-----------------------------------------------------|
| Git tags only (no branches) | Doesn’t allow continuous patch releases             |
| Separate repos per major    | Duplication, overhead, complex dependency management|
| Feature flags within one branch | Too fragile; mixes incompatible runtime versions |

---

## 6. Open Questions
- Should versioned documentation be deployed automatically for maintenance branches or manually triggered?
- Do we enforce a fixed EOL window (e.g., 12 months after next major)?
- Should we generate branch badges (coverage, build) per maintenance line on the docs site?

---

## 7. Next Steps
- Review and approve this RFC.
- Create GitHub issues aligned with the Implementation Plan phases.
- Begin rollout starting with Phase 0: Policy & Governance.

---

## 8. Configuration

Multi-version release and maintenance branch support is **disabled by default**. To enable it, set the environment variable `ENABLE_MULTI_RELEASE=true` before running release or CI workflows.

This flag must be configured **at repository creation time** (e.g., during template setup). It determines the repository’s release mode (single vs multi-version) permanently for that codebase. Toggling it later is not supported because it changes branching, CI, and publishing assumptions.


Example:

```bash
export ENABLE_MULTI_RELEASE=true
pnpm run release
```

### Workflows and Scripts Respecting `ENABLE_MULTI_RELEASE`
- **CI workflows:** Trigger on `main` only when disabled; on `main` and `release/*` when enabled.
- **Coverage baselines:** Branch-specific artifacts and comparisons only active when enabled.
- **Changesets:** Versioning, publishing, and major bump guards apply per branch only when enabled.
- **Documentation generation:** Versioned docs and version switcher enabled only when multi-release is active.
- **Branching and maintenance policies:** Long-lived release branches and related tooling are active only if the flag is set.

**Important:**  
The `ENABLE_MULTI_RELEASE` flag is a repository-level configuration decided during template creation.  
Switching it on or off later can lead to inconsistent branch and artifact behavior.  
A pre-check step should validate its presence and consistency across all workflows.
# RFC: Multi-Version Release & Maintenance Branch Strategy

**Date:** 2025-10-25  
**Status:** Draft  
**Author:** @derese-getachew  
**Tags:** release-management, ci, versioning, documentation, changesets

---

## 1. Overview

As our monorepo hosts multiple libraries that evolve independently, we must support fixing and publishing older major versions (e.g., `lib@1.x`) while developing new ones (`lib@2.x`).  
Currently, our CI, docs, and publishing flows assume a single “main” branch, which prevents concurrent version maintenance.

This RFC proposes a **multi-version release workflow** that can be **enabled or disabled via environment configuration**, ensuring flexibility across repositories.

---

## 2. Modes of Operation

| Mode | Description | Typical Use Case |
|------|--------------|------------------|
| **Single-Release Mode (default)** | Only one active line (`main`). No maintenance branches. | Simpler projects or MVP phase. |
| **Multi-Release Mode** (`ENABLE_MULTI_RELEASE=true`) | Supports concurrent major versions via long-lived maintenance branches. | Stable libraries with LTS support. |

---

## 3. Branching Strategy

| Branch Type | Example | Purpose |
|--------------|----------|----------|
| Active Development | `main` | Latest version, open for breaking changes. |
| Maintenance | `release/<package>_<major>` | Frozen major line for security patches and bug fixes. |

### Rules
- Branches are created **when a new major release is introduced**.  
- Each branch maintains its own `.changeset`, coverage baseline, and documentation snapshot.
- `main` always represents the **latest** line.
- Merging from `main` → `release/*` is not allowed; only cherry-picking is supported.

---

## 4. Release Workflow

### 4.1 Manual Process

When shipping a new major:

1. **Create a maintenance branch for the previous major**
   ```bash
   # Before releasing v2.0.0
   git checkout -b release/inbox_1 main
   git push origin release/inbox_1
   ```

2. **Switch back to `main` and release the new major**
   ```bash
   git checkout main
   pnpm changeset version
   git commit -am "chore(release): version bump for v2"
   git push origin main
   pnpm changeset publish
   ```

**Outcome:**
- `main` → `v2.x` (latest)  
- `release/inbox_1` → `v1.x` (maintenance)

Each line releases independently and keeps isolated changelogs and tags.

---

### 4.2 Future: Automated Branch Creation

We plan to introduce a script (`scripts/pre-major-check.ts`) that runs **before** `pnpm changeset version`:

- Reads all pending `.changeset/*.md` files.
- Detects any upcoming `major` bumps.
- Creates and pushes the corresponding `release/<package>_<oldMajor>` branch automatically (if missing).
- Runs only when `ENABLE_MULTI_RELEASE=true`.

This guarantees maintenance branches are never forgotten before bumping a major.

---

## 5. CI & Coverage

### Goals
- Each branch has isolated test coverage and artifact baselines.
- Workflows adapt automatically based on the active release mode.

### Implementation
- **Single-release:** triggers only on `main`.
- **Multi-release:** triggers on `main` and all `release/*` branches.

```yaml
on:
  push:
    branches:
      - main
      - release/*
```

**Branch-specific artifacts:**
- `coverage-baseline-main`
- `coverage-baseline-release_inbox_1`

Coverage comparison always happens within the same branch scope.

**Runtime Matrix Example:**
```yaml
- name: Set Node version per branch
  run: |
    if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
      echo "NODE_VERSION=20" >> $GITHUB_ENV
    elif [[ "${{ github.ref }}" =~ release/inbox_1 ]]; then
      echo "NODE_VERSION=18" >> $GITHUB_ENV
    fi
```

---

## 6. Documentation Versioning

| Branch | Output Path | Status |
|---------|--------------|--------|
| `main` | `/docs/inbox/v2` | Active |
| `release/inbox_1` | `/docs/inbox/v1` | Maintenance |

### Behavior
- Docs generator writes to `docs/generated/<package>/<majorLine>/…`
- A version switcher (v1 ↔ v2) appears only in multi-release mode.
- `/v1` docs are frozen except for security or bug-fix updates.

---

## 7. Dependency, Security, and Tooling Policy

- Dependabot runs only on `main`.  
- Security backports to maintenance branches are manual but limited to supported versions.
- Runtime-related vulnerabilities (e.g., Node/NestJS) must be patched manually in each maintained branch.

**CODEOWNERS**
```text
release/* @core-maintainers
```

**Branch Protections**
- Require PR + CI pass.
- Restrict direct merges.
- Encourage cherry-pick (`git cherry-pick <sha>`) for backports.

---

## 8. Contributor Workflow

| Scenario | Action |
|-----------|---------|
| Bug in both versions | Fix on `main`, cherry-pick to `release/*`. |
| Bug only in old version | Fix directly on `release/*`. |
| New feature / breaking change | Implement on `main` only. |
| Security fix | Apply to all active lines still under support. |

---

## 9. Maintenance Policy

A shared `SUPPORTED_VERSIONS.md` defines all maintained versions:

| Package | Line | Node | NestJS | Status | Maintained Until |
|----------|------|-------|--------|---------|------------------|
| @nestcourier/inbox | 2.x | ≥ 20 | ^11 | Active | — |
| @nestcourier/inbox | 1.x | ≥ 18 < 22 | ^10 | Maintenance | 2026‑06‑30 |

---

## 10. Configuration

Multi-version release mode is **disabled by default**.  
To enable it at repository creation:

```bash
export ENABLE_MULTI_RELEASE=true
pnpm release
```

### Important Rules
- `ENABLE_MULTI_RELEASE` is a **repository mode**, not a runtime toggle.  
- It must be defined during template setup and remain stable thereafter.
- Switching modes later is unsupported.

### Script Behavior

| Mode | `pnpm release` Flow |
|------|--------------------|
| Single-release | `pnpm changeset publish` |
| Multi-release | `pre-major-check → changeset version → commit → push → changeset publish` |

### CI Validation
CI pre-checks must confirm the flag matches the repo configuration.  
If missing or inconsistent, workflows should exit with a clear error.

---

## 11. Trade-offs

**Pros**
- True long-term support for older majors.
- Branch-isolated CI, docs, and changelogs.
- Predictable version lifecycles and semver stability.

**Cons**
- Slightly higher CI complexity.
- Duplicate configurations across branches.
- Manual or scripted maintenance effort required.

---

## 12. Next Steps

1. Approve this RFC.  
2. Implement repository pre-checks and `pre-major-check` script.  
3. Roll out CI updates and documentation versioning.  
4. Start with one package (e.g., `@nestcourier/inbox`) as a pilot.

---

This RFC establishes a scalable foundation for **multi-version, multi-branch releases** that can evolve into fully automated LTS management while preserving simplicity for single-line projects.